
// This file was generated by KeY Version 2.6.3 (internal: 19f0b8c2a4fe689cd76be6cd1753b36e2e825a89) (www.key-project.org).

/** This class enables the test suite to read and write protected and private
 * fields of other classes. It can also simulate ghost fields using a hashmap.
 * Ghostfields are implicit fields that exist in the specification but not in the
 * actual Java class. Futhermore, this class also enables to create an object of 
 * any class even if it has no default constructor. To create objects the 
 * the objenesis library is required and must be provided when compiling and
 * executing the test suite. 
 * @see http://docs.oracle.com/javase/tutorial/reflect/member/ctorInstance.html
 * @see http://code.google.com/p/objenesis/
 * @see http://objenesis.org/
 * @author gladisch
 * @author mbender
 */
package bank;


public class RFL {

  private static final String NoSuchFieldExceptionText;  public static boolean ghostMapActive;  public static java.util.HashMap<Integer,Object> ghostModelFields;

  public static int getHash(Class<?> c, Object obj, String attr){
    return c.hashCode() * (obj!=null?obj.hashCode():1) * attr.hashCode();
  }



   static{
   objenesis = new org.objenesis.ObjenesisStd();
   ghostMapActive = true;
   ghostModelFields = new java.util.HashMap<Integer,Object>();
   NoSuchFieldExceptionText =
        "This exception occurs when ghost fields or model fields are used in the code or " +
        "if mock objects are used that have different fields, than the real objects. " +
        "The tester should extend the handling of such fields in this generated utility class RFL.java.";
}



  /** The Objenesis library can create instances of classes that have no default constructor. */
  private static org.objenesis.Objenesis objenesis;

  private static Object newInstance(Class c) throws Exception {
    Object res=objenesis.newInstance(c);
    if (res==null)
      throw new Exception("Couldn't create instance of class:"+c);
  return res;
  }

  // ---The methods for object creation---


  public static bank.HashTable newbank_HashTable() throws java.lang.RuntimeException {
    try{
      return (bank.HashTable)newInstance(bank.HashTable.class);
    } catch (java.lang.Throwable e) {
       throw new java.lang.RuntimeException(e);
    }
  }

  public static java.lang.Object[] newjava_lang_Object_ARRAY_(int dim){
    return new java.lang.Object[dim];
  }

  public static java.lang.ArrayIndexOutOfBoundsException newjava_lang_ArrayIndexOutOfBoundsException() throws java.lang.RuntimeException {
    try{
      return (java.lang.ArrayIndexOutOfBoundsException)newInstance(java.lang.ArrayIndexOutOfBoundsException.class);
    } catch (java.lang.Throwable e) {
       throw new java.lang.RuntimeException(e);
    }
  }


  // ---Getter and setter for primitive types---


  public static void _set_int(Class<?> c, Object obj, String attr, int val) throws RuntimeException{
    try {
      java.lang.reflect.Field f = c.getDeclaredField(attr);
      f.setAccessible(true);
      f.setInt(obj, val);
    } catch(NoSuchFieldException e) {
      if(ghostMapActive)
        ghostModelFields.put(getHash(c,obj,attr), val);
      else
        throw new RuntimeException(e.toString() + NoSuchFieldExceptionText);
    } catch(Exception e) {
      throw new RuntimeException(e);
    }
  }

  public static int _get_int(Class<?> c, Object obj, String attr) throws RuntimeException{
    int res = 0;
    try {
      java.lang.reflect.Field f = c.getDeclaredField(attr);
      f.setAccessible(true);
      return f.getInt(obj);
      } catch(NoSuchFieldException e) {
      return (Integer)ghostModelFields.get(getHash(c,obj,attr));
    } catch(Exception e) {
      throw new RuntimeException(e);
    }
  }


  public static void _set_long(Class<?> c, Object obj, String attr, long val) throws RuntimeException{
    try {
      java.lang.reflect.Field f = c.getDeclaredField(attr);
      f.setAccessible(true);
      f.setLong(obj, val);
    } catch(NoSuchFieldException e) {
      if(ghostMapActive)
        ghostModelFields.put(getHash(c,obj,attr), val);
      else
        throw new RuntimeException(e.toString() + NoSuchFieldExceptionText);
    } catch(Exception e) {
      throw new RuntimeException(e);
    }
  }

  public static long _get_long(Class<?> c, Object obj, String attr) throws RuntimeException{
    long res = 0;
    try {
      java.lang.reflect.Field f = c.getDeclaredField(attr);
      f.setAccessible(true);
      return f.getLong(obj);
      } catch(NoSuchFieldException e) {
      return (Long)ghostModelFields.get(getHash(c,obj,attr));
    } catch(Exception e) {
      throw new RuntimeException(e);
    }
  }


  public static void _set_byte(Class<?> c, Object obj, String attr, byte val) throws RuntimeException{
    try {
      java.lang.reflect.Field f = c.getDeclaredField(attr);
      f.setAccessible(true);
      f.setByte(obj, val);
    } catch(NoSuchFieldException e) {
      if(ghostMapActive)
        ghostModelFields.put(getHash(c,obj,attr), val);
      else
        throw new RuntimeException(e.toString() + NoSuchFieldExceptionText);
    } catch(Exception e) {
      throw new RuntimeException(e);
    }
  }

  public static byte _get_byte(Class<?> c, Object obj, String attr) throws RuntimeException{
    byte res = 0;
    try {
      java.lang.reflect.Field f = c.getDeclaredField(attr);
      f.setAccessible(true);
      return f.getByte(obj);
      } catch(NoSuchFieldException e) {
      return (Byte)ghostModelFields.get(getHash(c,obj,attr));
    } catch(Exception e) {
      throw new RuntimeException(e);
    }
  }


  public static void _set_char(Class<?> c, Object obj, String attr, char val) throws RuntimeException{
    try {
      java.lang.reflect.Field f = c.getDeclaredField(attr);
      f.setAccessible(true);
      f.setChar(obj, val);
    } catch(NoSuchFieldException e) {
      if(ghostMapActive)
        ghostModelFields.put(getHash(c,obj,attr), val);
      else
        throw new RuntimeException(e.toString() + NoSuchFieldExceptionText);
    } catch(Exception e) {
      throw new RuntimeException(e);
    }
  }

  public static char _get_char(Class<?> c, Object obj, String attr) throws RuntimeException{
    char res = ' ';
    try {
      java.lang.reflect.Field f = c.getDeclaredField(attr);
      f.setAccessible(true);
      return f.getChar(obj);
      } catch(NoSuchFieldException e) {
      return (Character)ghostModelFields.get(getHash(c,obj,attr));
    } catch(Exception e) {
      throw new RuntimeException(e);
    }
  }


  public static void _set_boolean(Class<?> c, Object obj, String attr, boolean val) throws RuntimeException{
    try {
      java.lang.reflect.Field f = c.getDeclaredField(attr);
      f.setAccessible(true);
      f.setBoolean(obj, val);
    } catch(NoSuchFieldException e) {
      if(ghostMapActive)
        ghostModelFields.put(getHash(c,obj,attr), val);
      else
        throw new RuntimeException(e.toString() + NoSuchFieldExceptionText);
    } catch(Exception e) {
      throw new RuntimeException(e);
    }
  }

  public static boolean _get_boolean(Class<?> c, Object obj, String attr) throws RuntimeException{
    boolean res = false;
    try {
      java.lang.reflect.Field f = c.getDeclaredField(attr);
      f.setAccessible(true);
      return f.getBoolean(obj);
      } catch(NoSuchFieldException e) {
      return (Boolean)ghostModelFields.get(getHash(c,obj,attr));
    } catch(Exception e) {
      throw new RuntimeException(e);
    }
  }


  public static void _set_float(Class<?> c, Object obj, String attr, float val) throws RuntimeException{
    try {
      java.lang.reflect.Field f = c.getDeclaredField(attr);
      f.setAccessible(true);
      f.setFloat(obj, val);
    } catch(NoSuchFieldException e) {
      if(ghostMapActive)
        ghostModelFields.put(getHash(c,obj,attr), val);
      else
        throw new RuntimeException(e.toString() + NoSuchFieldExceptionText);
    } catch(Exception e) {
      throw new RuntimeException(e);
    }
  }

  public static float _get_float(Class<?> c, Object obj, String attr) throws RuntimeException{
    float res = 0;
    try {
      java.lang.reflect.Field f = c.getDeclaredField(attr);
      f.setAccessible(true);
      return f.getFloat(obj);
      } catch(NoSuchFieldException e) {
      return (Float)ghostModelFields.get(getHash(c,obj,attr));
    } catch(Exception e) {
      throw new RuntimeException(e);
    }
  }


  public static void _set_double(Class<?> c, Object obj, String attr, double val) throws RuntimeException{
    try {
      java.lang.reflect.Field f = c.getDeclaredField(attr);
      f.setAccessible(true);
      f.setDouble(obj, val);
    } catch(NoSuchFieldException e) {
      if(ghostMapActive)
        ghostModelFields.put(getHash(c,obj,attr), val);
      else
        throw new RuntimeException(e.toString() + NoSuchFieldExceptionText);
    } catch(Exception e) {
      throw new RuntimeException(e);
    }
  }

  public static double _get_double(Class<?> c, Object obj, String attr) throws RuntimeException{
    double res = 0;
    try {
      java.lang.reflect.Field f = c.getDeclaredField(attr);
      f.setAccessible(true);
      return f.getDouble(obj);
      } catch(NoSuchFieldException e) {
      return (Double)ghostModelFields.get(getHash(c,obj,attr));
    } catch(Exception e) {
      throw new RuntimeException(e);
    }
  }


  // ---Getter and setter for Reference types---


  public static void _set_bank_HashTable(Class<?> c, Object obj, String attr, bank.HashTable val) throws RuntimeException{
    try {
      java.lang.reflect.Field f = c.getDeclaredField(attr);
      f.setAccessible(true);
      f.set(obj, val);
    } catch(NoSuchFieldException e) {
      if(ghostMapActive)
        ghostModelFields.put(getHash(c,obj,attr), val);
      else
        throw new RuntimeException(e.toString() + NoSuchFieldExceptionText);
    } catch(Exception e) {
      throw new RuntimeException(e);
    }
  }

  public static bank.HashTable _get_bank_HashTable(Class<?> c, Object obj, String attr) throws RuntimeException{
    bank.HashTable res = null;
    try {
      java.lang.reflect.Field f = c.getDeclaredField(attr);
      f.setAccessible(true);
      return (bank.HashTable) f.get(obj);
      } catch(NoSuchFieldException e) {
      return (bank.HashTable)ghostModelFields.get(getHash(c,obj,attr));
    } catch(Exception e) {
      throw new RuntimeException(e);
    }
  }


  public static void _set_java_lang_Object_ARRAY_(Class<?> c, Object obj, String attr, java.lang.Object[] val) throws RuntimeException{
    try {
      java.lang.reflect.Field f = c.getDeclaredField(attr);
      f.setAccessible(true);
      f.set(obj, val);
    } catch(NoSuchFieldException e) {
      if(ghostMapActive)
        ghostModelFields.put(getHash(c,obj,attr), val);
      else
        throw new RuntimeException(e.toString() + NoSuchFieldExceptionText);
    } catch(Exception e) {
      throw new RuntimeException(e);
    }
  }

  public static java.lang.Object[] _get_java_lang_Object_ARRAY_(Class<?> c, Object obj, String attr) throws RuntimeException{
    java.lang.Object[] res = null;
    try {
      java.lang.reflect.Field f = c.getDeclaredField(attr);
      f.setAccessible(true);
      return (java.lang.Object[]) f.get(obj);
      } catch(NoSuchFieldException e) {
      return (java.lang.Object[])ghostModelFields.get(getHash(c,obj,attr));
    } catch(Exception e) {
      throw new RuntimeException(e);
    }
  }


  public static void _set_java_lang_ArrayIndexOutOfBoundsException(Class<?> c, Object obj, String attr, java.lang.ArrayIndexOutOfBoundsException val) throws RuntimeException{
    try {
      java.lang.reflect.Field f = c.getDeclaredField(attr);
      f.setAccessible(true);
      f.set(obj, val);
    } catch(NoSuchFieldException e) {
      if(ghostMapActive)
        ghostModelFields.put(getHash(c,obj,attr), val);
      else
        throw new RuntimeException(e.toString() + NoSuchFieldExceptionText);
    } catch(Exception e) {
      throw new RuntimeException(e);
    }
  }

  public static java.lang.ArrayIndexOutOfBoundsException _get_java_lang_ArrayIndexOutOfBoundsException(Class<?> c, Object obj, String attr) throws RuntimeException{
    java.lang.ArrayIndexOutOfBoundsException res = null;
    try {
      java.lang.reflect.Field f = c.getDeclaredField(attr);
      f.setAccessible(true);
      return (java.lang.ArrayIndexOutOfBoundsException) f.get(obj);
      } catch(NoSuchFieldException e) {
      return (java.lang.ArrayIndexOutOfBoundsException)ghostModelFields.get(getHash(c,obj,attr));
    } catch(Exception e) {
      throw new RuntimeException(e);
    }
  }
}
